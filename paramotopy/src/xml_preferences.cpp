#include "xml_preferences.hpp"

//NUMPOSSIBLE_SAVEFILES is set in xml_preferences.hpp
const char * const ProgSettings::possible_savefiles[NUMPOSSIBLE_SAVEFILES] =
{ "real_solutions", "nonsingular_solutions", "singular_solutions", "raw_data", "raw_solutions","main_data","midpath_data"   };


//NUMMANDATORY_SAVEFILES is set in xml_preferences.hpp
const char * const ProgSettings::mandatory_savefiles[NUMMANDATORY_SAVEFILES] =
{ "failed_paths" };












//writes a config header for a bertini input file to the configname file.
//this is based entirely off data stored in the preferences, eliminating the need for the user to have to
//carry around their own config files.
std::string ProgSettings::WriteConfigStepOne(){
  
  std::stringstream config;
  //note that bertini parses right over white space.  input files can also be commented.
  config << "CONFIG\n%this config automatically generated by paramotopy\n\n";
  settingmap::iterator iter;
  for (iter=settings["step1bertini"].begin(); iter != settings["step1bertini"].end(); iter++){
    std::string setting_name = (*iter).first;
    config << setting_name << ": "
		<< settings["step1bertini"][setting_name].value() << ";\n";
  }
  
  config	<< "END;\n\n";
  return config.str();
}



//writes a config header for a bertini input file to the configname file.
//this is based entirely off data stored in the preferences, eliminating the need for the user to have to
//carry around their own config files.
std::string ProgSettings::WriteConfigStepTwo(){
	
	
	
  std::stringstream config;
  //note that bertini parses right over white space.  input files can also be commented with percent signs.
  config << "CONFIG\n%this config automatically generated by paramotopy\n\n";
  
  settingmap::iterator iter;
  
  for (iter=settings["step2bertini"].begin(); iter != settings["step2bertini"].end(); iter++){
    std::string setting_name = (*iter).first;
    config << setting_name << ": "
		<< settings["step2bertini"][setting_name].value() << ";\n";
  }
  if (this->settings["mode"]["standardstep2"].intvalue==1){ // if not a standard step2, doing regular bertini runs on multiple
		// parameter points
    config << "USERHOMOTOPY: 1;\n";
	}
  config << "END;\n\n";
  
  return config.str();
}


//writes a config header for a bertini input file to the configname file.
//this is based entirely off data stored in the preferences, eliminating the need for the user to have to
//carry around their own config files.
std::string ProgSettings::WriteConfigFail(){
	
	
  std::stringstream config;
  //note that bertini parses right over white space.  input files can also be commented with percent signs.
  config << "CONFIG\n%this config automatically generated by paramotopy\n\n";
  
  settingmap::iterator iter;
  
  for (iter=settings["PathFailureBertiniCurrent"].begin(); iter != settings["PathFailureBertiniCurrent"].end(); iter++){
    std::string setting_name = (*iter).first;
    config << setting_name << ": "
		<< settings["PathFailureBertiniCurrent"][setting_name].value() << ";\n";
  }
  if (this->settings["mode"]["standardstep2"].intvalue==1){ // if not a standard step2, doing regular bertini runs on multiple
		// parameter points
    config << "USERHOMOTOPY: 1;\n";
	}
  config << "END;\n\n";
  
  return config.str();
}













//related to path failure analysis
void ProgSettings::tightentolerances(){
  settings["PathFailureBertiniCurrent"]["TRACKTOLBEFOREEG"].doubvalue = 0.1*settings["PathFailureBertiniCurrent"]["TRACKTOLBEFOREEG"].doubvalue;
  settings["PathFailureBertiniCurrent"]["TRACKTOLDURINGEG"].doubvalue = 0.1*settings["PathFailureBertiniCurrent"]["TRACKTOLDURINGEG"].doubvalue;
  settings["PathFailureBertiniCurrent"]["FINALTOL"].doubvalue = 0.1*settings["PathFailureBertiniCurrent"]["FINALTOL"].doubvalue;
  
  ProgSettings::save();
  
  return;
}


void ProgSettings::set_path_failure_settings_from_steptwo(){
	
  settings["PathFailureBertiniBase"].clear();
  settingmap::iterator iter;
  
  for (iter=settings["step2bertini"].begin(); iter != settings["step2bertini"].end(); iter++){
    std::string setting_name = (*iter).first;
    switch (settings["step2bertini"][setting_name].type) {
			case 0:
				setValue("PathFailureBertiniBase",setting_name,settings["step2bertini"][setting_name].value());
				break;
			case 1:
				setValue("PathFailureBertiniBase",setting_name,settings["step2bertini"][setting_name].intvalue);
				break;
			case 2:
				setValue("PathFailureBertiniBase",setting_name,settings["step2bertini"][setting_name].doubvalue);
				break;
			default:
				break;
    }
  }
	
  ProgSettings::save();
  
  return;
}
//sets path failure settings from the PathFailureBertiniBase settings
void ProgSettings::set_path_failure_settings(){
  
  settings["PathFailureBertiniCurrent"].clear();
  settingmap::iterator iter;
  
  for (iter=settings["PathFailureBertiniBase"].begin(); iter != settings["PathFailureBertiniBase"].end(); iter++){
    std::string setting_name = (*iter).first;
    switch (settings["PathFailureBertiniBase"][setting_name].type) {
			case 0:
				setValue("PathFailureBertiniCurrent",setting_name,settings["PathFailureBertiniBase"][setting_name].value());
				break;
			case 1:
				setValue("PathFailureBertiniCurrent",setting_name,settings["PathFailureBertiniBase"][setting_name].intvalue);
				break;
			case 2:
				setValue("PathFailureBertiniCurrent",setting_name,settings["PathFailureBertiniBase"][setting_name].doubvalue);
				break;
			default:
				break;
    }
  }
  
  ProgSettings::save();
	
  return;
}













void ProgSettings::default_main_values(){
  
	setValue("files","writemeshtomc",int(0));
	setValue("files","customtmplocation",0);
	setValue("files","tempfilelocation",boost::filesystem::path("."));
	setValue("files","newfilethreshold",67108864);
	
	setValue("system","buffersize",65536);
	setValue("system","stifle",int(0));
	
	for (int j=0; j<NUMMANDATORY_SAVEFILES; ++j) {
    setValue("SaveFiles",mandatory_savefiles[j],1);
  }
	
	for (int j = 0; j < NUMPOSSIBLE_SAVEFILES;++j){
		setValue("SaveFiles",possible_savefiles[j],0);
		//		if (settings["SaveFiles"][possible_savefiles[j]].intvalue != 1){//!FilePrefVector[j]
		//			std::cout << j+1 << ") " << possible_savefiles[j] << "\n";
		//		}
	}
	
	setValue("SaveFiles","nonsingular_solutions",1);
	setValue("SaveFiles","real_solutions",1);
	
	
	setValue("parallelism","usemachine",int(0));
	setValue("parallelism","parallel",int(1));
	setValue("parallelism","architecture",std::string("mpiexec"));
	setValue("parallelism","numprocs",int(2));
	setValue("parallelism","numfilesatatime",100);
	
  setValue("files","newrandom_newfolder",0);
  setValue("files","previousdatamethod",1);
  setValue("files","deletetmpfilesatend",1);
	
	setValue("mode","main_mode",0);
	setValue("mode","startfilename",std::string("nonsingular_solutions"));
  setValue("mode","standardstep2",1); // do a parameter homotopy from a start file by default
  return;
}


void ProgSettings::default_basic_bertini_values_stepone(){
	
	// these should all be the same as default bertini settings.
  settings["step1bertini"].clear();
  setValue("step1bertini","TRACKTOLBEFOREEG",1e-5);
  setValue("step1bertini","TRACKTOLDURINGEG",1e-6);
  setValue("step1bertini","FINALTOL",1e-11);
  setValue("step1bertini","IMAGTHRESHOLD",1e-8);
  ProgSettings::save();
  return;
}


void ProgSettings::default_basic_bertini_values_steptwo(){
  
	// these should all be the same as default bertini settings.
  settings["step2bertini"].clear();
  setValue("step2bertini","TRACKTOLBEFOREEG",1e-5);
  setValue("step2bertini","TRACKTOLDURINGEG",1e-6);
  setValue("step2bertini","FINALTOL",1e-11);
  setValue("step2bertini","IMAGTHRESHOLD",1e-8);
  ProgSettings::save();
  return;
}

void ProgSettings::default_basic_bertini_values_pathfailure(){
  settings["PathFailureBertiniBase"].clear();
  //the bertini defaults from the user's manual
  setValue("PathFailureBertiniBase","TRACKTOLBEFOREEG",1e-5);
  setValue("PathFailureBertiniBase","TRACKTOLDURINGEG",1e-6);
  setValue("PathFailureBertiniBase","FINALTOL",1e-11);
  setValue("PathFailureBertiniBase","IMAGTHRESHOLD",1e-8);
  ProgSettings::save();
  return;
}

void ProgSettings::default_path_failure_settings(){
	
  setValue("PathFailure","newrandommethod",1);
  setValue("PathFailure","tightentolerances",1);
  setValue("PathFailure","maxautoiterations",1);
  ProgSettings::save();
  return;
}



//switching for calling specific functions to get required settings.  i did this to try to avoid a mess of if then statements.
void ProgSettings::RequiredSettingsSwitcharoo(int settingcase){
	
  switch (settingcase) {
			
			
			
			
			
			
			
			
			
			//parallelism
		case 001:
			ProgSettings::GetArchitecture();
			break;
		case 002:
			ProgSettings::GetParallel();
			break;
		case 003:
			ProgSettings::GetNumFilesTime();
			break;
			
			//files
			
			
		case 102:
			ProgSettings::GetWriteMCFileUserDef();
			break;
		case 103:
			ProgSettings::GetDeleteTmpFiles();
			break;
			
		case 105:
			ProgSettings::GetDataFolderMethod();
			break;
		case 106:
			ProgSettings::GetNewRandomAtNewFolder();
			break;
		case 107:
			ProgSettings::GetSaveProgress();
			break;
		case 108:
			ProgSettings::GetNewFileThresh();
			break;
		case 109:
			ProgSettings::GetTemporaryFileLocation();
			break;
			
			
			
			
			//mode
		case 201:
			ProgSettings::SetStandardStep2();
			break;
		case 202:
			ProgSettings::SetSearchMode();
			break;
		case 203:
			ProgSettings::GetStartFileName();
			break;
			
			
			
			//system
		case 300:
			ProgSettings::FindProgram("bertini","system","bertinilocation");//step2 is the program name
			break;
		case 301:
			ProgSettings::FindProgram("step2","system","step2location");//step2 is the program name
			break;
		case 302:
			ProgSettings::GetStifle();
			break;
		case 303:
			ProgSettings::GetBufferSize();
			break;
			
		default:
			
			std::cout << "GetPref code not yet written for case " << settingcase << "\n";
			break;
  }
  return;
};


//checks whether have a set of required settings
bool ProgSettings::setRequiredValues(){
	
  bool made_changes = false;
  
  std::stringstream menustream;
  std::map<std::string,std::pair< int, std::string > >::iterator iter;
  
  static std::map< std::string,std::pair< int, std::string> > main_required_values;
	
	//parallelism
  main_required_values["architecture"].first = 001; main_required_values["architecture"].second = "parallelism";
  main_required_values["parallel"].first = 002; main_required_values["parallel"].second = "parallelism";
	main_required_values["numfilesatatime"].first = 003; main_required_values["numfilesatatime"].second = "parallelism";
	
	//files
	main_required_values["writemeshtomc"].first = 102; main_required_values["writemeshtomc"].second = "files";
  main_required_values["deletetmpfilesatend"].first = 103; main_required_values["deletetmpfilesatend"].second = "files";
  main_required_values["previousdatamethod"].first = 105; main_required_values["previousdatamethod"].second = "files";
  main_required_values["newrandom_newfolder"].first = 106; main_required_values["newrandom_newfolder"].second = "files";
  main_required_values["saveprogresseverysomany"].first = 107; main_required_values["saveprogresseverysomany"].second = "files";
  main_required_values["newfilethreshold"].first  = 108; main_required_values["newfilethreshold"].second = "files";
  main_required_values["tempfilelocation"].first = 109; main_required_values["tempfilelocation"].second = "files";
  
	
	
	
	
	//mode
	main_required_values["standardstep2"].first = 201; main_required_values["standardstep2"].second = "mode";
	main_required_values["main_mode"].first = 202; main_required_values["main_mode"].second = "mode";
	main_required_values["startfilename"].first = 203; main_required_values["startfilename"].second = "mode";
  //adding a required value here requires adding a ProgSettings::Get___() function, and adding an option to switch
  
	
	
	
	
	//system
	main_required_values["bertinilocation"].first = 300; main_required_values["bertinilocation"].second = "system";
  main_required_values["step2location"].first = 301; main_required_values["step2location"].second = "system";
  main_required_values["stifle"].first = 302; main_required_values["stifle"].second = "system";
  main_required_values["buffersize"].first = 303; main_required_values["buffersize"].second = "system";
  
  //iterate over the main setting map, for each of the above settings.
  for (iter=main_required_values.begin(); iter != main_required_values.end(); iter++) {
    if (settings[(*iter).second.second].find( (*iter).first) == settings[(*iter).second.second].end() )
			// search in cat name for setting of cat name
		{ // if fail to find a setting of the name in the category.
      ProgSettings::RequiredSettingsSwitcharoo( (*iter).second.first ); // feed in the integer
      made_changes = true;
    }
	}
  return made_changes;
}










void ProgSettings::GetProgramLocationManual(std::string program_name, std::string category_name, std::string setting_name){
	
  size_t found;
  std::string path_to_detect;
  std::cout << "please supply the path to " << program_name << ".  (% cancels) \n: \n";
  path_to_detect = getAlphaNumeric();
  
  path_to_detect = replace_tilde_with_home(path_to_detect);
  
  found=path_to_detect.find('%');
  if ( (int(found)==0) ) {
    return;
  }
  
  boost::filesystem::path temp_path(path_to_detect);
  temp_path /= program_name;
  while (! boost::filesystem::exists(temp_path)) {
    std::cout << program_name << " program not found at " << temp_path.string() << ".  please supply the path (% cancels)\n: \n";
    path_to_detect = getAlphaNumeric();
    found=path_to_detect.find('%');
    if ( (int(found)==0) ) {
      return;
    }
    temp_path = boost::filesystem::path(path_to_detect);
    temp_path /= program_name;
  }
  
  boost::filesystem::path final_path = boost::filesystem::canonical(boost::filesystem::absolute(path_to_detect));
  
  setValue(category_name,setting_name,final_path);
  
  std::cout << program_name << " location set to " << final_path.string() << std::endl;
  return;
}

//locates the .
void ProgSettings::FindProgram(std::string program_name, std::string category_name, std::string setting_name){
	
  bool found_program = false;
  
  
  if (haveSetting(category_name,setting_name)) {
    boost::filesystem::path stored_location(settings[category_name][setting_name].pathvalue);
    stored_location /= program_name;
    if (boost::filesystem::exists(stored_location)){
      stored_location = boost::filesystem::canonical(boost::filesystem::absolute(stored_location));
      setValue(category_name,setting_name,stored_location.parent_path());
      found_program = true;
    }
    
    
  }
  
  if (found_program == false ){
    boost::filesystem::path here = "./";
    here /= program_name;
    
    if (boost::filesystem::exists(here)){  // if have the step2 program in current directory, set location of it to here.
      here = boost::filesystem::absolute(here);
      setValue(category_name,setting_name,here.parent_path());
      found_program = true;
    }
    else{  //if step2 is not in the current directory, then scan the path for it.
      
      char * temp_path;
      temp_path = getenv ("PATH");
      if (temp_path!=NULL){
				std::string path = std::string(temp_path);
				//have the path variable.  will scan for the mystep2 program.
				
				
				
				size_t found;
				found = path.find(':');
				while (found!=std::string::npos) {  //if found the delimiter ':'
					boost::filesystem::path path_to_detect(path.substr(0,found));  //the part of the path to scan for mystep2
					path = path.substr(found+1,path.length()-found);    // the remainder of the path.  will scan later.
					found = path.find(':');                             // get the next indicator of the ':' delimiter.
					path_to_detect /= program_name;
					if (boost::filesystem::exists(path_to_detect)){
						//found the mystep2 program!
						
						setValue(category_name,setting_name,path_to_detect.parent_path());
						found_program = true;
						break;
						
					}
					else{
						//did not find it yet...
					}
				}// re:while
      }//re: if temp_path!=null
      else{ //the path variable was null.  WTF?
				std::cerr << "unable to scan $PATH for step2.\n";
				
      }
    }
  }
  
  
  if (found_program == false){
    std::string path_to_detect;
    std::cout << program_name << " program not found in current directory or PATH.\nplease supply the path to " << program_name << ".\n: ";
    path_to_detect = getAlphaNumeric();
    boost::filesystem::path temp_path(path_to_detect);
    temp_path /= program_name;
    while (! boost::filesystem::exists(temp_path)) {
      std::cout << program_name << " program not found at that location.  please supply the path: \n";
      path_to_detect = getAlphaNumeric();
      temp_path = boost::filesystem::path(path_to_detect);
      temp_path /= program_name;
    }
    setValue(category_name,setting_name,boost::filesystem::path(path_to_detect) );
  }
  
  
  boost::filesystem::path final_path = boost::filesystem::canonical(boost::filesystem::absolute(settings[category_name][setting_name].pathvalue));
  
  setValue(category_name,setting_name,final_path);
  
  return;
}//    re: find_program






//gets files to save from user.  also sets to save all mandatory files.
void ProgSettings::SetSaveFiles(){
	
  for (int j = 0; j < NUMPOSSIBLE_SAVEFILES; ++j) {
    setValue("SaveFiles",possible_savefiles[j],0);
  }
  
  
  int selection = -1;
  while (selection!=0){
    std::cout << "\n\nPossible files to save:\n\n";
    for (int j = 0; j < NUMPOSSIBLE_SAVEFILES;++j){
      if (settings["SaveFiles"][possible_savefiles[j]].intvalue != 1){//!FilePrefVector[j]
				std::cout << j+1 << ") " << possible_savefiles[j] << "\n";
      }
    }
    std::cout << "*\n" << 0 << ") Done.\n";
    selection = get_int_choice("Select the file you would like to save : ",0,NUMPOSSIBLE_SAVEFILES);
    
    
    if (selection!=0){
      setValue("SaveFiles",possible_savefiles[selection-1],1);
    }
  }
  //done setting files to save for this run.
  
  
  for (int j=0; j<NUMMANDATORY_SAVEFILES; ++j) {
    setValue("SaveFiles",mandatory_savefiles[j],1);
  }
	ProgSettings::save();
};


//gives false bool if didn't have all the files previously noted for saving state.  true if did.
bool ProgSettings::CheckPrevSetFiles(){
  bool had_all = true;
  for (int j=0; j<NUMPOSSIBLE_SAVEFILES; ++j) {
    if (settings["SaveFiles"].find( possible_savefiles[j] ) == settings["SaveFiles"].end()) {
      had_all = false;
    }
  }
  return had_all;
};

//
////gets the save state for individual file, determined by user through the console
//void ProgSettings::GetIndividualFileSave(std::string datafilename){
//  std::stringstream ss;
//  ss << "Would you like to save data contained in files named '" << datafilename << "'?\n0 no, 1 yes\n:";
//  setValue("SaveFiles",datafilename, get_int_choice(ss.str(),0,1));
//}














//the main function to save the preferences to a xml file.
void ProgSettings::save(boost::filesystem::path save_filename){
  
  TiXmlDocument* doc = new TiXmlDocument;
  TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );
  
  doc->LinkEndChild( decl );
  
  TiXmlElement * root = new TiXmlElement("paramotopy_preferences");
  categorymap::iterator iter;
  
  //save each catergory
  for (iter=settings.begin(); iter!= settings.end(); iter++) {
    ProgSettings::SaveCategoryToXml( (*iter).first , (*iter).second ,root);
  }
  
  //wrap it up
  doc->LinkEndChild( root );
  
  //save it
  if(doc->SaveFile(save_filename.string())){  //filename is a data member of ProgSettings class
    //		std::cout << "preferences saved\n";
  }
  else{
    //couldn't save for some reason.  this may be a problem on queued systems?
    std::cout << "preferences *failed* to save to " << 	save_filename.string() << "!\n";
  };
  
}



//saves one category of settings to the xml file.  returns to calling function save() for next category or finalization.
int ProgSettings::SaveCategoryToXml(std::string catname, settingmap curr_settings , TiXmlElement* root){
  
  TiXmlText* setting_name;
  TiXmlText* setting_value;
  TiXmlText* setting_type;
  
  std::stringstream ss;
  
  
  TiXmlElement * category_name = new TiXmlElement( catname.c_str() );
  
  settingmap::iterator iter;
  for (iter=curr_settings.begin(); iter != curr_settings.end(); iter++){
    TiXmlElement* setting_elmnt = new TiXmlElement("setting");
    
    const std::string & key=(*iter).first;
    const std::string & type=(*iter).second.typestr();
    const std::string & value=(*iter).second.value();
    
    
		
    setting_name = new TiXmlText(key.c_str());
    setting_value = new TiXmlText(value.c_str());
    setting_type = new TiXmlText(type.c_str());
    
    
    TiXmlElement* name_elmnt = new TiXmlElement("name");
    name_elmnt->LinkEndChild(setting_name);
    TiXmlElement* value_elmnt = new TiXmlElement("value");
    value_elmnt->LinkEndChild(setting_value);
    TiXmlElement* type_elmnt = new TiXmlElement("type");
    type_elmnt->LinkEndChild(setting_type);
    
    setting_elmnt->LinkEndChild(name_elmnt );
    setting_elmnt->LinkEndChild(value_elmnt );
    setting_elmnt->LinkEndChild( type_elmnt);
    
    
    category_name->LinkEndChild(setting_elmnt);
    
    
  }
  root->LinkEndChild(category_name);
  
  return 0;
}



int ProgSettings::check_for_existing_prefs_auto(boost::filesystem::path & load_filename, boost::filesystem::path pFilename){
	
	
	int found_a_file;
	if (boost::filesystem::exists(pFilename)) {
		load_filename = pFilename;
		found_a_file = 1;
	}
	else{
		std::cout << "failed to find the desired settings file" << pFilename << std::endl;
		load_filename = ProgSettings::default_name();
		if (boost::filesystem::exists(load_filename)) {
			found_a_file = 2;
		}
		else
		{
			found_a_file = 0;
		}
	}
	
	
	return found_a_file;
	
}



boost::filesystem::path ProgSettings::default_name(){
	boost::filesystem::path defaultsettings(getenv("HOME"));
	defaultsettings /= ".paramotopy/defaultprefs.xml";
	return defaultsettings;
}


boost::filesystem::path ProgSettings::make_settings_name(boost::filesystem::path newfilename){
	
	boost::filesystem::path settingsfilename(getenv("HOME"));
	settingsfilename /= ".paramotopy/";
	settingsfilename /= newfilename;
	settingsfilename += "prefs.xml";
	return settingsfilename;
}


void ProgSettings::load_interactive(){
	
	boost::filesystem::path load_filename;
	
	boost::filesystem::path source_folder = getenv("HOME");
	source_folder /= ".paramotopy";
	
	std::string expression = "prefs.xml\\z";  //specify beginning of string
	expression.append("");
	std::vector < boost::filesystem::path > filelist = FindFiles(source_folder, expression);  //this function is in para_aux_funcs
	
	
	std::stringstream menu;
  int choice = -1;
	
	menu << "found these preferences file:\n-----------------\n0) current (no change)\n";
	for (int ii=0; ii<int(filelist.size()); ii++) {
		boost::filesystem::path temppath = filelist[ii];
		
		menu << ii+1 << ") " << temppath.filename() << std::endl;
	}
	menu << "--------\nwhich to load?";
  
	choice = get_int_choice(menu.str(),0,filelist.size());
	switch (choice) {
		case 0:
			//do nothing, not loading.
			break;
			
			
		default:
			// load the user's choice.
			ProgSettings::load(filelist[choice-1].string().c_str());
			break;
	}
	
	
	
	
	
	
	
	
}

//attempts to open the pFilename.  if cannot, checks for required values.  also goes through reset if xml file is broken.
void ProgSettings::load(boost::filesystem::path pFilename){
	
	//	this->filename = pFilename;
  bool changesmade=false, load_defaults = false, doc_loaded = false;
  
  //clear the old settings from memory.
	//TODO: change this to an iterator operation
	
	//	this->settings.clear();
	//
  settings["parallelism"].clear();
  settings["step1bertini"].clear();
  settings["step2bertini"].clear();
  settings["PathFailure"].clear();
  settings["SaveFiles"].clear();
  settings["files"].clear();
	settings["system"].clear();
	
	
	boost::filesystem::path load_filename;
	int found_a_file = check_for_existing_prefs_auto(load_filename, pFilename);//set the value of load_filename
	//returns 0 if neither desired nor default file is found.
	// 1 if the desired file is found
	// 2 if only default is found, instead of desired.
	
	
	if (this->filename.string().size()==0) { // unset
		//		std::cout << "changing filename" << std::endl;
		this->filename = load_filename;
	}
	
	if (found_a_file==0 || found_a_file==2) {
		changesmade=true;
	}
	
	if (found_a_file>0){
		std::cout << "loading preferences from " << load_filename.string() << "\n";
		TiXmlDocument* doc = new TiXmlDocument(load_filename.string().c_str());
		doc_loaded = doc->LoadFile();
		
		
		if (!doc_loaded) {
			changesmade = true;
			load_defaults = true;
		}
		else {
			
			TiXmlHandle hDoc(doc);
			TiXmlElement* pElem;
			TiXmlHandle hRoot(0);
			
			
			pElem=hDoc.FirstChildElement().Element();
			// should always have a valid root but handle gracefully if it doesn't
			
			if (!pElem) {
				std::cerr << "bad xml file for prefs.  :( todo: check for backup\n";
				load_defaults = true;
				changesmade=true;
			}
			else{
				std::string main_name =pElem->Value(); 
				
				hRoot=TiXmlHandle(pElem);  // the handle for the data we will be reading
				
				TiXmlElement* catElem=hRoot.FirstChild().Element();
				for (catElem; catElem; catElem=catElem->NextSiblingElement()) {
					ProgSettings::ReadCategoryFromXml(catElem->Value(),hRoot);
				}
			}
		}
  }
  else{
		load_defaults=true;
	}
	
	
	
	
	if (load_defaults) {
		
		std::cout << "setting preferences to defaults.\n";
		ProgSettings::default_basic_bertini_values_stepone();
		ProgSettings::default_basic_bertini_values_steptwo();
		ProgSettings::default_basic_bertini_values_pathfailure();
		ProgSettings::default_path_failure_settings();
		ProgSettings::default_main_values();
		ProgSettings::save();
		
		changesmade=true;
	}
	
  bool made_changes_required_values = ProgSettings::setRequiredValues();  //check for required settings, and set them if not found already.
  
  if (made_changes_required_values) {
    changesmade = true;
  }
  
  if (!ProgSettings::CheckPrevSetFiles()) {
    ProgSettings::SetSaveFiles();
    changesmade=true;
  }
  
  ProgSettings::FindProgram("step2","system","step2location");
  ProgSettings::FindProgram("bertini","system","bertinilocation");
  
	
	
	
  if (changesmade) {//only save settings if made a change.
    ProgSettings::save();
  }
	
	if (load_defaults || (!boost::filesystem::exists(ProgSettings::default_name())) || changesmade) {
		ProgSettings::save(ProgSettings::default_name());
	}
	
	
	
}

//for reading individual settings categories from the xml file.
int ProgSettings::ReadCategoryFromXml(std::string catname, TiXmlHandle hRoot){
	
  std::stringstream ss;
  int type;
  int intvalue;
  double doubvalue;
  
  TiXmlElement* pElem=hRoot.FirstChild( catname.c_str() ).FirstChild().Element();
  for( pElem; pElem; pElem=pElem->NextSiblingElement())
	{
		TiXmlHandle setting_handle(pElem);  //get the handle for the setting
		
		
		TiXmlElement* qElem = setting_handle.FirstChild("name").Element();  //read the name
		const char *nameText=qElem->GetText();
		
		qElem = setting_handle.FirstChild("value").Element();  //read the value
		const char *valueText=qElem->GetText();
		
		qElem = setting_handle.FirstChild("type").Element();  //read the type
		const char *typeText=qElem->GetText();
		
		
		if (nameText && valueText && typeText)
		{ //setting is ok.  set the setting.
			
			
			ss << typeText;
			ss >> type;
			ss.clear();
			ss.str("");
			
			//according to type integer (0=string, 1=integer, 2=double), store in the setting map
			switch (type) {
				case 0: //string
					ProgSettings::setValue(catname,nameText,std::string(valueText));
					break;
					
				case 1: //integer
					ss << valueText;
					ss >> intvalue;
					ss.clear();
					ss.str("");
					ProgSettings::setValue(catname,nameText,intvalue);
					break;
					
				case 2: //double
					ss << valueText;
					ss >> doubvalue;
					ss.clear();
					ss.str("");
					ProgSettings::setValue(catname,nameText,doubvalue);
					break;
					
				case 3: //boost::filesystem::path
					ProgSettings::setValue(catname,nameText,boost::filesystem::path(valueText));
					break;
					
				default:
					std::cout << "bad type set somehow, from xml prefs file.\n"
					<< "cat: " << catname << " name: " << nameText << " type: " << type << std::endl;
					break;
			}
			
		}
	}
  
  return 0;
}

















void ProgSettings::ManagePathFailureBertini(){
  std::stringstream menu;
  menu << "\n\nManage Path Failure Bertini:\n\n"
	<< "1) Change Setting\n"
	<< "2) Remove Setting\n"
	<< "3) Add Setting\n"
	<< "4) Reset to Default Path Failure Bertini Settings\n"
	<< "5) Import From current Step2 Settings\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
  int choice = -1001;
  while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("PathFailureBertiniBase");
    
    choice = get_int_choice(menu.str(),0,5);
    
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::ChangeSetting("PathFailureBertiniBase");
				break;
				
			case 2:
				ProgSettings::RemoveSetting("PathFailureBertiniBase");
				break;
				
			case 3:
				ProgSettings::AddSetting("PathFailureBertiniBase");
				break;
				
			case 4:
				settings["PathFailureBertiniBase"].clear();
				ProgSettings::default_basic_bertini_values_pathfailure();
				break;
				
			case 5:
				settings["PathFailureBertiniBase"].clear();
				ProgSettings::set_path_failure_settings_from_steptwo();
				break;
				
			default:
				std::cout << "somehow an unacceptable entry submitted :(\n";
				break;
    }
    ProgSettings::save();
    
  }
  return;
}


void ProgSettings::ChangeSetting(std::string category_name){
  //first, get setting name
  std::string setting_name = "neverusethisname";
  size_t found;
  
  while ( 1 ) {
    std::cout << "what is the exact name of setting?   % cancels\n: ";
    setting_name = getAlphaNumeric();
    
    boost::to_upper(setting_name);
    
    found=setting_name.find('%');
    if ( (haveSetting(category_name,setting_name)) ||  (int(found)==0) ) {
      break;
    }
  }
  
  if (int(found)==0) {
    std::cout <<  "canceling\n";
    return;
  }
  
  
  
	
  std::cout << "new value\n:";
  std::string newvalue;
  newvalue = getAlphaNumeric();  // do type-specific stuff in the switch below.
  
  std::stringstream converter;
  int intie;
  double doubie;
  switch (settings[category_name][setting_name].type) {
		case 0:
			setValue(category_name,setting_name,newvalue);
			break;
		case 1:
			converter << newvalue;
			converter >> intie;
			setValue(category_name,setting_name,intie);
			break;
		case 2:
			converter << newvalue;
			converter >> doubie;
			setValue(category_name,setting_name,doubie);
			break;
		default:
			break;
  }
  ProgSettings::save();
}


// adds a setting to category_name.  prompts the user for setting name, type, and value.
void ProgSettings::AddSetting(std::string category_name){
  //first, get setting name
  std::string setting_name = "neverusethisname";
  
  
  std::cout << "what is the exact name of setting?     % cancels\n: ";
  setting_name = getAlphaNumeric();
  
  boost::to_upper(setting_name);
  
  size_t found=setting_name.find('%');
  if ( int(found)==0 ) {
    std::cout << "canceling\n";
    return;
  }
  
	
	
  std::stringstream prompt;
  prompt << "what is the type of "
	<< setting_name
	<< "?\n 0 = string\n 1 = integer / 0-1 bool\n 2= float/double\n\n:";
  int typeint = get_int_choice(prompt.str(),0,2);
  
  
  std::cout << "enter setting value" << std::endl <<  ": ";
  
	
  std::string newvalue = getAlphaNumeric();
  std::stringstream converter;
  converter << newvalue;
  int intie;
  double doubie;
  switch (typeint) {
		case 0:
			setValue(category_name,setting_name,converter.str());
			break;
		case 1:
			converter >> intie;
			setValue(category_name,setting_name,intie);
			break;
		case 2:
			converter >> doubie;
			setValue(category_name,setting_name,doubie);
			break;
		default:
			break;
  }
  ProgSettings::save();
  return;
}


//removes a setting from a category.
void ProgSettings::RemoveSetting(std::string category_name){
  std::string setting_name = "neverusethisname";
  
  size_t found;
  
  while (1) {
	  
    std::cout << "what is the exact name of setting?    % cancels\n";
    setting_name = getAlphaNumeric();
    
    boost::to_upper(setting_name);
    
    found=setting_name.find('%');
    if ( (haveSetting(category_name,setting_name)) ||  (int(found)==0) ) {
      std::cout << "no setting of that name." << std::endl;
      break;
    }
	}
  
  if (int(found)==0) {
    std::cout <<  "canceling\n";
    return;
  }
	
  
  settings[category_name].erase(setting_name);
  
  ProgSettings::save();
  return;
}


//for a category_name, writes setting names and values to the screen

void ProgSettings::DisplayCurrentSettings(std::string category_name){
	
  settingmap::iterator iter;
	
	int max_name_length = 0;
	for (iter=settings[category_name].begin(); iter != settings[category_name].end(); iter++){
    std::string setting_name = (*iter).first;
    if (int(setting_name.size())>max_name_length) {
			max_name_length = int(setting_name.size());
		}
  }
	
	int min_dist = 5;
	
  std::cout << "\n\n" << category_name << " current settings:\n"
	<< "   -name-";
  for (int i=0; i< max_name_length+min_dist-9; ++i) {
    std::cout << " ";
  }
  std::cout << "-value-\n";
  for (iter=settings[category_name].begin(); iter != settings[category_name].end(); iter++){
    std::string setting_name = (*iter).first;
    std::cout << setting_name;
    for (int i=0; i<(max_name_length+min_dist-int(setting_name.length())); ++i) {
      std::cout << " ";
    }
    std::cout << settings[category_name][(*iter).first].value() << "\n";
  }
  
  return;
}























void ProgSettings::MainMenu(){
  std::stringstream menu;
  int choice = -1;
  menu << "\n\n\nPreferences Main Menu:\n\n"
	<< "1) Bertini settings\n"
	<< "2) Solver Modes\n"
	<< "3) Path failure resolution\n"
	<< "4) Parallelism\n"
	<< "5) Set files to save\n"
	<< "6) System Settings\n"
	<< "7) File IO\n"
	<< "8) MetaSettings\n"
	<< "*\n0) return to paramotopy\n"
	<< "\n: ";
  
	
  while (choice!=0) {
    choice = get_int_choice(menu.str(),0,8);
    
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::BertiniMenu();
				break;
				
			case 2:
				ProgSettings::SolverModeMenu();
				break;
				
			case 3:
				ProgSettings::PathFailureMenu();
				break;
				
			case 4:
				ProgSettings::ParallelismMenu();
				break;
				
			case 5:
				ProgSettings::SaveFilesMenu();
				break;
				
			case 6:
				ProgSettings::SystemMenu();
				break;
				
			case 7:
				ProgSettings::FileMenu();
				break;
				
				
			case 8:
				ProgSettings::MetaSettingsMenu();
				break;
				
			default:
				std::cout << "somehow an unacceptable entry submitted to MainMenu :(\n";
				break;
    }
		//    ProgSettings::save();
  }
  return;
}


void ProgSettings::BertiniMenu(){
  std::stringstream menu;
  int choice=-10;
  
  menu << "\n\nBertini Settings:\n\n"
	<< "1) Step 1 Settings\n"
	<< "2) Step 2 Settings\n"
	<< "3) Path Failure Bertini Settings\n"
	<< "*\n"
	<< "0) go back\n"
	<< "\n: ";
  while (choice!=0) {
    choice = get_int_choice(menu.str(),0,3);
    
    switch (choice) {
			case 0:
				
				break;
				
			case 1:
				ProgSettings::StepOneMenu();
				break;
				
			case 2:
				ProgSettings::StepTwoMenu();
				break;
				
			case 3:
				ProgSettings::ManagePathFailureBertini();
				break;
				
				
			default:
				std::cout << "somehow an unacceptable entry submitted to BertiniMenu\n";
				//seriously, how did you get here?
				break;
		}
  }
  return;
}






void ProgSettings::SolverModeMenu(){
	std::stringstream menu;
  int choice=-10;
  
  menu << "\n\nSolver Mode Settings:\n\n"
	<< "1) Brute-force -vs- Search.\n"
	<< "2) Standard step2 run.\n"
	<< "3) File to use for step2 start file\n"
	<< "*\n"
	<< "0) go back\n"
	<< "\n: ";
  while (choice!=0) {
		ProgSettings::DisplayCurrentSettings("mode");
    choice = get_int_choice(menu.str(),0,3);
    
    switch (choice) {
			case 0:
				
				break;
				
				
			case 1:
				ProgSettings::SearchMenu();
				break;
				
				
			case 2:
				ProgSettings::SetStandardStep2();
				break;
				
				
			case 3:
				ProgSettings::GetStartFileName();
				break;
				
				
			default:
				std::cout << "somehow an unacceptable entry submitted to SolverModeMenu\n";
				//seriously, how did you get here?
				break;
		}
  }
  return;
	
	
}


void ProgSettings::SearchMenu(){
	
	std::stringstream menu;
	int choice=-10;
	
	while (choice!=0) {
		
		
		int upper_limit = 1;
		menu << "\n\nSearch Settings:\n\n";
		
		
		
		
		if (this->settings["mode"]["main_mode"].intvalue==1) {
			menu
			<< "1) Turn Search Mode Off.\n"
			<< "2) Max num searches\t\t" << settings["mode"]["search_iterations"].value() << "\n"
			<< "3) Desired number solutions\t" << settings["mode"]["search_desirednumber"].value() << "\n"
			<< "4) Submode -- thresholding for number of posreal\n";
			upper_limit = 4;
			
			if (this->settings["mode"]["search_submode"].intvalue==1) {
				menu
				<< "5) Threshold number for number of posreal solutions at a point\t"
				<< this->settings["mode"]["search_numposrealthreshold_lower"].intvalue
				<< " <= numsolns <= ";
				
				if (this->settings["mode"]["search_numposrealthreshold_upper"].intvalue==-1) {
					menu << "inf";}
				else{
					menu << this->settings["mode"]["search_numposrealthreshold_upper"].intvalue;
				}
				menu << "\n";
				upper_limit = 5;
			}
			
		}
		else{
			menu
			<< "1) Turn Search Mode On.\n";
		}
		
		
		menu << "*\n"
		<< "0) go back\n"
		<< "\n: ";
		
		
		ProgSettings::DisplayCurrentSettings("mode");
		choice = get_int_choice(menu.str(),0,upper_limit);
		
		switch (choice) {
			case 0:
				
				break;
				
				
			case 1:
				if (this->settings["mode"]["main_mode"].intvalue==1) {
					setValue("mode","main_mode",0);
				}
				else{
					setValue("mode","main_mode",1);
					
					if (this->settings["mode"].find("search_iterations") == settings["mode"].end() )
						// search in cat name for setting of cat name
					{ // if fail to find a setting of the name in the category.
						ProgSettings::SetSearchIterations();
					}
					
					if (this->settings["mode"].find("search_desirednumber") == settings["mode"].end() )
						// search in cat name for setting of cat name
					{ // if fail to find a setting of the name in the category.
						ProgSettings::SetSearchDesiredNumber();
					}
					
					
				}
				ProgSettings::save();
				break;
				
				
			case 2:
				ProgSettings::SetSearchIterations();
				break;
				
			case 3:
				ProgSettings::SetSearchDesiredNumber();
				break;
				
				
			case 4:
				ProgSettings::SetSearchSubmode();
				break;
				
			case 5:
				ProgSettings::SetSearchPosRealThresh();
				break;
				
				
			default:
				std::cout << "somehow an unacceptable entry submitted to SearchMenu\n";
				//seriously, how did you get here?
				break;
		}
	}
	return;
	
}

void ProgSettings::SystemMenu(){
  std::stringstream menu;
  int choice=-10;
  
  menu << "\n\nSystem Settings:\n\n"
	<< "1) Stifle Step2 Output\n"
	<< "2) Change Buffer Size\n"
	<< "3) Set location of bertini executable\n"
	<< "4) Set location of step2 executable\n"
	
	<< "*\n"
	<< "0) go back\n"
	<< "\n: ";
  while (choice!=0) {
		
		ProgSettings::DisplayCurrentSettings("system");
    choice = get_int_choice(menu.str(),0,4);
    
    switch (choice) {
			case 0:
				
				break;
				
			case 1:
				ProgSettings::GetStifle();
				break;
				
			case 2:
				ProgSettings::GetBufferSize();
				break;
				
			case 3:
				ProgSettings::GetProgramLocationManual("bertini","system","bertinilocation");
				break;
				
			case 4:
				ProgSettings::GetProgramLocationManual("step2","system","step2location");
				break;
				
				
				
			default:
				std::cout << "somehow an unacceptable entry submitted to SystemMenu\n";
				//seriously, how did you get here?
				break;
		}
  }
  return;
}

void ProgSettings::FileMenu(){
	
	std::stringstream menu;
	int choice = -10;
	menu << "\n\nFiles, &c:\n\n"
	<< "1) Which folder to load at startup\n"
	<< "2) Generation of random values when creating new folder\n"
	<< "3) Set temp file location / Use ramdisk for temp files\n"
	<< "4) Max data file Size / New file threshold\n"
	<< "5) Deletion of temp files at end of run\n"
	<< "6) Generation of mc mesh file for non-user-def runs\n"
	
	<< "*\n"
	<< "0) go back\n"
	<< "\n: ";
	
	
	while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("files");
    choice = get_int_choice(menu.str(),0,6);
    
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::GetDataFolderMethod();
				break;
				
			case 2:
				ProgSettings::GetNewRandomAtNewFolder();
				break;
				
				
			case 3:
				ProgSettings::GetTemporaryFileLocation();
				break;
				
				
			case 4:
				ProgSettings::GetNewFileThresh();
				break;
				
			case 5:
				ProgSettings::GetDeleteTmpFiles();
				break;
				
			case 6:
				ProgSettings::GetWriteMCFileUserDef();
				break;
				
			default:
				std::cout << "somehow an unacceptable entry submitted to FileMenu\n";
				break;
		}
	}
	
	
}


//submenu for settings.  this one for settings related to parallel
void ProgSettings::ParallelismMenu(){
  
  std::stringstream menu;
  int choice = -10;
  
  menu << "\n\nParallelism:\n\n"
	<< "1) Switch Parallel On/Off, and consequential others\n"
	<< "2) Number of Files to send to workers at a time\n"
	<< "3) Machinefile\n"
	<< "4) Architecture / calling\n"
	<< "5) Number of processors used\n"
	<< "*\n"
	<< "0) go back\n"
	<< "\n: ";
  
  while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("parallelism");
    choice = get_int_choice(menu.str(),0,5);
    
    switch (choice) {
			case 0:
				
				break;
				
			case 1:
				ProgSettings::GetParallel();
				break;
				
			case 2:
				ProgSettings::GetNumFilesTime();
				break;
				
			case 3:
				ProgSettings::GetMachineFile();
				break;
				
			case 4:
				ProgSettings::GetArchitecture();
				break;
				
			case 5:
				ProgSettings::GetNumProcs();
				break;
				
				
			default:
				std::cout << "somehow an unacceptable entry submitted :(\n";
				break;
    }
  }//while
  return;
}

//submenu, for step 1 solve settings.
void ProgSettings::StepOneMenu(){
  std::stringstream menu;
  
  menu << "\n\nStep1 Settings:\n\n"
	<< "1) Change Setting\n"
	<< "2) Remove Setting\n"
	<< "3) Add Setting\n"
	<< "4) Reset to Default Settings\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
	int choice = -1001;
	while (choice!=0) {
	  ProgSettings::DisplayCurrentSettings("step1bertini");
	  
	  choice = get_int_choice(menu.str(),0,4);
	  
	  switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::ChangeSetting("step1bertini");
				break;
				
			case 2:
				ProgSettings::RemoveSetting("step1bertini");
				break;
				
			case 3:
				ProgSettings::AddSetting("step1bertini");
				break;
				
			case 4:
				settings["step1bertini"].clear();
				ProgSettings::default_basic_bertini_values_stepone();
				break;
				
			default:
				std::cout << "somehow an unacceptable entry submitted :(\n";
				break;
	  }
		//	  ProgSettings::save();
	}
	
	
	return;
}


//sets options for step2 bertini whatnot
void ProgSettings::StepTwoMenu(){
  
  std::stringstream menu;
  menu << "\n\nBasic Step2 Settings:\n\n"
	
	<< "1) Change Setting\n"
	<< "2) Remove Setting\n"
	<< "3) Add Setting\n"
	<< "4) Reset to Default Settings\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
  int choice = -1001;
  while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("step2bertini");
    
    choice = get_int_choice(menu.str(),0,4);
    
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::ChangeSetting("step2bertini");
				break;
				
			case 2:
				ProgSettings::RemoveSetting("step2bertini");
				break;
				
			case 3:
				ProgSettings::AddSetting("step2bertini");
				break;
				
			case 4:
				settings["step2bertini"].clear();
				ProgSettings::default_basic_bertini_values_steptwo();
				break;
				
			default:
				std::cout << "somehow an unacceptable entry submitted :(\n";
				break;
    }
		//    ProgSettings::save();
  }
  return;
}



//for choosing options for dealing with path failure
void ProgSettings::PathFailureMenu(){
  std::stringstream menu;
  menu << "\n\nPath Failure Settings:\n\n"
	<< "1) Choose random-start-point Method\n"
	<< "2) Tolerance Tightening\n"
	<< "3) Set Num Iterations\n"
	<< "5) Manage Bertini Settings\n"
	<< "7) Reset fully to Default path failure Settings\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
  int choice = -1001;
  while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("PathFailure");
    choice = get_int_choice(menu.str(),0,7);
    
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::GetRandomMethod();
				break;
				
				
			case 2:
				ProgSettings::GetTightenTolerancesPathFailure();
				break;
				
			case 3:
				ProgSettings::GetNumIterations();
				break;
				
			case 5:
				ProgSettings::ManagePathFailureBertini();
				break;
			case 7:
				settings["PathFailure"].clear();
				ProgSettings::default_path_failure_settings();
				settings["PathFailureBertiniBase"].clear();
				ProgSettings::default_basic_bertini_values_pathfailure();
				break;
			default:
				break;
    }
  }
  
  
  ProgSettings::save();
  return;
}



//sets the saving of output files from bertini in the step2 process.
void ProgSettings::SaveFilesMenu(){
	
  std::stringstream menu;
  menu << "\n\nFiles to Save:\n\n"
	<< "1) Change Files to Save\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
  int choice = -1001;
  while (choice!=0) {
    ProgSettings::DisplayCurrentSettings("SaveFiles");
    choice = get_int_choice(menu.str(),0,1);
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::SetSaveFiles();
				break;
				
			default:
				break;
    }
  }
  
	
  return;
}


void ProgSettings::MetaSettingsMenu(){
	
	
	std::stringstream menu;
  menu << "\n\nMeta Settings:\n\n"
       << "1) Load a set of settings\n"
       << "2) Save current settings as default\n"
       << "3) Save the system settings to file\n"
	<< "*\n"
	<< "0) Go Back\n"
	<< "\n: ";
  int choice = -1001;
  while (choice!=0) {
    choice = get_int_choice(menu.str(),0,3);
    switch (choice) {
			case 0:
				break;
				
			case 1:
				ProgSettings::load_interactive();
				break;
				
			case 2:
				ProgSettings::save(ProgSettings::default_name());
				break;
                        case 3:

                                ProgSettings:save();
			        std::cout << "Saved preferences to " << this->filename << "\n";
			        break;
			default:
				break;
    }
  }
	return;
	
}
















































void ProgSettings::GetParallel(){//case 2
  std::stringstream menustream;
  std::string valstr;
  menustream << "Run Parallel?\n"
	<< "0) No.\n"
	<< "1) Yes.\n"
	<<  "Enter choice : ";
  int parselect = get_int_choice(menustream.str(), 0, 1);
  
  if (parselect==0)
    setValue("parallelism","parallel",0);
  else
		setValue("parallelism","parallel",1);
  
  if (parselect==1){
    ProgSettings::GetMachineFile();
    ProgSettings::GetNumProcs();
	}//re: if parselect
  else{
    setValue("parallelism","numfilesatatime",1);
  }//re: else
  return;
}


//changing/setting the archtecture for parallel calling step2 and bertini.  eventually this will be deprecated
void ProgSettings::GetArchitecture(){ //case 1
  std::string valstr;
  std::stringstream menustream;
  
  menustream << "Select your command for running parallel processes:\n"
	<< "0) mpiexec\n"
	<< "1) aprun\n"
	<< "2) other... (you will enter your own command [sadly not calling pattern yet :( ])\n:";
  int val = get_int_choice(menustream.str(), 0, 2);
  
  switch (val) {
		case 0:
			valstr = "mpiexec";
			break;
		case 1:
			valstr = "aprun";
			break;
		case 2:
			std::cout << "enter your own command:\n";
			valstr = getAlphaNumeric_WithSpaces();
			break;
		default:
			//how did you get here?
			break;
  }
  
  setValue("parallelism","architecture",valstr);
  
  return;
};

void ProgSettings::GetMachineFile(){
  std::string valstr = "";
  int valint = get_int_choice("Does your machine use a machinefile?\n0) No.\n1) Yes.\n: ",0,1);
  
  
  
  
  if (valint==1) {
    boost::filesystem::path home(getenv("HOME"));
    size_t found;
    
    while (1) {
      std::cout << "Enter the machine file to be used, relative to your home directory:  (% cancels)" << std::endl;
      
      
      if (settings["parallelism"].find("machinefile") != settings["parallelism"].end()) {
				std::cout << "     enter @ to use previous machinefile " << this->settings["parallelism"]["machinefile"].value() << std::endl;
      }
      
      valstr = getAlphaNumeric();
      
      
      
			
      found=valstr.find('%');
      if ( (int(found)==0) && (settings["parallelism"].find("usemachine") != settings["parallelism"].end())   ) {
				return;
      }
      
      found=valstr.find('@');
      if ( (settings["parallelism"].find("machinefile") != settings["parallelism"].end())  &&  (int(found)==0)  ) {
				valstr = this->settings["parallelism"]["machinefile"].value();
      }
      
      boost::filesystem::path testme = home;
      testme /= valstr;
      
      if (boost::filesystem::exists(testme)) {
				break;
      }
      else{
				std::cout << "cannot find that file." << std::endl;
      }
    }
    
    
    
    setValue("parallelism","machinefile",valstr);
  }
	
  setValue("parallelism","usemachine",valint);
  return;
};

void ProgSettings::GetNumProcs(){
	
  setValue("parallelism","numprocs",get_int_choice( "Enter the number of processes to be run: ",0,9000000));
  return;
};

void ProgSettings::GetNumFilesTime(){
  
  int valint = get_int_choice("Enter step2 number of files at a time per processor:   (0 for default of 100)",0,9000000);
  
  if (valint==0){
    setValue("parallelism","numfilesatatime",100);
  }
  else{
    setValue("parallelism","numfilesatatime",valint);
  }
  return;
};

void ProgSettings::GetDeleteTmpFiles(){
  int val = get_int_choice("Delete temp files at end of runs?  (0 for no, 1 for yes)\n:",0,1);
  setValue("files","deletetmpfilesatend",val);
  return;
};


void ProgSettings::GetSaveProgress(){
  
  std::stringstream menustream;
  
  setValue("files","saveprogresseverysomany",1);
  return;
};

void ProgSettings::GetNewFileThresh(){
	
	
  int val = get_int_choice("Threshold in bytes for new data file \n (press 0 for default of 67108864 = 2^26): ",0,2147483647);
  if (val == 0) {
    setValue("files","newfilethreshold",67108864);
  }
  else{
    setValue("files","newfilethreshold",val);
  }
  return;
};

void ProgSettings::GetBufferSize(){
  std::stringstream menustream;
  int val = get_int_choice("How many KB should step2 buffer before writing data to disk? (max 65536K = 64MB)\n (press 0 for default of 64K): ",0,65536);
  if (val == 0) {
    ProgSettings::setValue("system","buffersize",65536);
  }
  else{
    ProgSettings::setValue("system","buffersize",val*1024);
  }
  return;
}


//detects whether /dev/shm is a location, and if so, offers to use /dev/shm for the temporary files.
void ProgSettings::GetTemporaryFileLocation(){
  std::stringstream menustream;
  size_t found;
  std::vector< boost::filesystem::path > tmpfile_location_possibilities;
  
  std::vector< boost::filesystem::path > standard_places_to_look;
  standard_places_to_look.push_back("/dev/shm");
  standard_places_to_look.push_back("/tmp");
  
  if (get_int_choice("Would you like to use a custom location for temp files?\n0) No.\n1) Yes.\n: ",0,1)==1){
    
    setValue("files","customtmplocation",1);
    for (int ii=0; ii<int(standard_places_to_look.size()); ++ii) {
      if (boost::filesystem::exists(standard_places_to_look[ii])){
				tmpfile_location_possibilities.push_back(standard_places_to_look[ii]);
      }
    }
    
    if (tmpfile_location_possibilities.size()>0){ //if actually found places
      std::cout << "Found these possibilities:\n\n";
      
      for (int ii = 0; ii< int(tmpfile_location_possibilities.size()); ++ii) {
				std::cout << ii << ": " << tmpfile_location_possibilities[ii].string() << std::endl;
      }
      std::cout << "-or-\n" << tmpfile_location_possibilities.size() << ": specify your own location. (will not check it exists or even works) todo: perform these checks\n\n";
      
      int choice=get_int_choice(": ",0,tmpfile_location_possibilities.size());
      if (choice==int(tmpfile_location_possibilities.size())) {
				std::string tmplocation;
				std::cout << "where should the root directory for temp files be?\n: " << std::endl;
				tmplocation = getAlphaNumeric();
				setValue("files","tempfilelocation",tmplocation);
			}
      else{
				setValue("files","tempfilelocation",standard_places_to_look[choice].string());
      }
    }
    else{//found none of the standard places to look
      std::string tmplocation;
      std::cout << "Did not find any of the standard places to look for shared memory access :(\n\n";
      std::cout << "where should the root directory for temp files be?  (% cancels, and chooses not to use ramdisk)\n: " << std::endl;
      tmplocation = getAlphaNumeric();
      found=tmplocation.find('%');
      if ( (int(found)==0) ) {
				setValue("files","customtmplocation",0);
				setValue("files","tempfilelocation",boost::filesystem::path("."));
      }
      else{
				setValue("files","tempfilelocation",boost::filesystem::path(tmplocation));
      }
    }
    
    
    
  }
  else {
    setValue("files","customtmplocation",0);
    setValue("files","tempfilelocation",boost::filesystem::path("."));
  }
  
  
  return;
};


//offers to use /dev/null to redirect step2 output
void ProgSettings::GetStifle(){
  std::stringstream menustream;
  
  setValue("system","stifle",get_int_choice("Stifle step2 output (to /dev/null) ?\n0) No.\n1) Yes.\n:",0,1));
  return;
};




void ProgSettings::GetWriteMCFileUserDef(){
  setValue("files","writemeshtomc",get_int_choice("would you like to produce an mc file during step2, when using computer-generated mesh?",0,1));
	ProgSettings::save();
  return;
}


void ProgSettings::SetSearchDesiredNumber()
{
	
	int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "How many points/solutions of desired type do you want?\n\n"
	<< " (Max value 1e6)\n"
	<< "\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),1,1e6);
	
	setValue("mode","search_desirednumber",choice);
	
	
	ProgSettings::save();
	
}

void ProgSettings::SetSearchIterations(){
	
	int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "What is the max number of point searches?\n\n"
	<< "0 for default of 100K.      Max value 1e8\n"
	<< "\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),0,1e8);
  switch (choice) {
		case 0:
			setValue("mode","search_iterations",int(1e5));
			break;
		default:
			setValue("mode","search_iterations",int(choice));
			break;
			
			
  }
	ProgSettings::save();
	
}


void ProgSettings::SetSearchSubmode()
{
	
	int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "Search for:\n"
	<< "0) total number of posreal solutions\n"
	<< "1) points with at least/most ___ solutions\n"
	<< "\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),0,1);
	setValue("mode","search_submode",choice);
	
	
	if (this->settings["mode"].find("search_numposrealthreshold_lower") == settings["mode"].end() ||
			this->settings["mode"].find("search_numposrealthreshold_upper") == settings["mode"].end())
		// search in cat name for setting of cat name
	{ // if fail to find a setting of the name in the category.
		ProgSettings::SetSearchPosRealThresh();
	}
	else{
		setValue("mode","search_numposrealthreshold_upper",int(1));
		setValue("mode","search_numposrealthreshold_lower",int(1));
	}
	ProgSettings::save();
	
}


void ProgSettings::SetSearchPosRealThresh(){
	
	int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "What is LOWER threshold number of posreal solutions for valid point?     (max 1e6)\n"
	<< "\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),0,1e6);
	setValue("mode","search_numposrealthreshold_lower",choice);
	menu.clear();
	menu.str("");
	
	menu << "\n\n"
	<< "What is UPPER threshold number of posreal solutions for valid point?     (max 1e6)\n"
	<< "-1 is no limit\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),-1,1e6);
	setValue("mode","search_numposrealthreshold_upper",choice);
	
	
	
	ProgSettings::save();
}


void ProgSettings::SetSearchMode(){
  int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "Which primary mode?\n\n"
	<< "0) Brute force, solve for all parameter points\n"
	<< "1) Search for posreal solutions in a space\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),0,1);
  switch (choice) {
		case 0:
			setValue("mode","main_mode",0);
			break;
		case 1:
			setValue("mode","main_mode",1);
			break;
		default:
			
			break;
  }
	
	if (this->settings["mode"]["main_mode"].intvalue==1) {
		setValue("SaveFiles","real_solutions",1);
		
		if (this->settings["mode"].find("search_iterations") == settings["mode"].end() )
			// search in cat name for setting of cat name
		{ // if fail to find a setting of the name in the category.
			ProgSettings::SetSearchIterations();
		}
		
		if (this->settings["mode"].find("search_desirednumber") == settings["mode"].end() )
			// search in cat name for setting of cat name
		{ // if fail to find a setting of the name in the category.
			ProgSettings::SetSearchDesiredNumber();
		}
		
		if (this->settings["mode"].find("search_submode") == settings["mode"].end() )
			// search in cat name for setting of cat name
		{ // if fail to find a setting of the name in the category.
			ProgSettings::SetSearchSubmode();
		}
		
		
		
		
	}
	
	
	ProgSettings::save();
}



void ProgSettings::SetStandardStep2(){
  int choice = -10;
  std::stringstream menu;
  menu << "Which method for the Step 2 run?\n\n"
	<< "0) Total Degree Step 2\n"
	<< "1) Standard Step 2\n"
	<< ": ";
  choice = get_int_choice(menu.str(),0,1);
  setValue("mode", "standardstep2", choice);
  ProgSettings::save();
}


void ProgSettings::GetDataFolderMethod(){
  int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "What to do at startup for folders?\n\n"
	<< "1) Use most recently used folder\n"
	<< "2) Make new folder\n"
	<< "3) Prompt if found previous folder\n"
	<< "\n: ";
  
  choice = get_int_choice(menu.str(),1,3);
  setValue("files","previousdatamethod",choice);
  ProgSettings::save();
  return;
  
}

void ProgSettings::GetStartFileName(){
  int choice = -10;
  std::stringstream menu;
  menu << "\n\n"
	<< "Which file to use for the start for step2?\n\n"
	<< "1) nonsingular_solutions\n"
	<< "2) finite_solutions\n"
	<< "\n: ";
	
  choice = get_int_choice(menu.str(),1,2);
  switch (choice) {
		case 1:
			setValue("mode","startfilename",std::string("nonsingular_solutions"));
			break;
		case 2:
			setValue("mode","startfilename",std::string("finite_solutions"));
			break;
		default:
			
			break;
  }
  
  ProgSettings::save();
  return;
}



void ProgSettings::GetNewRandomAtNewFolder(){
  
  int choice = -11;
  std::stringstream menu;
  menu << "\n\n"
	<< "If you make a new folder with program running do you want\n"
	<< "to automatically create new random values, or keep previous?\n"
	<< "0) no  (keep old)\n"
	<< "1) yes (make new)\n"
	<< "\n: ";
  
  choice = get_int_choice(menu.str(),0,1);
  
  setValue("files","newrandom_newfolder",choice);
  ProgSettings::save();
  return;
}







void ProgSettings::GetRandomMethod(){
  int choice = get_int_choice("use a new random start point for each resolve?  0 no, 1 yes\n: ",0,1);
  setValue("PathFailure","newrandommethod",choice);
  ProgSettings::save();
  return;
}


void ProgSettings::GetTightenTolerancesPathFailure(){
  int choice = get_int_choice("Tighten tolerance by 10x each iteration?  0 no, 1 yes\n: ",0,1);
  setValue("PathFailure","tightentolerances",choice);
  ProgSettings::save();
}

void ProgSettings::GetNumIterations(){
  int choice = get_int_choice("How many iterations to perform per re-run?\n: ",1,99999);
  setValue("PathFailure","maxautoiterations",choice);
  ProgSettings::save();
  return;
}
