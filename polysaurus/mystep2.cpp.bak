#include <mpi.h>
#include "step1.h"
#include "step2.h"
#include "mtrand.h"
#include "random.h"
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/types.h> 
#include <vector>

void master(std::vector<std::string> dir);
void slave(std::vector<std::string> dir, ToSave *TheFiles,int numfiles,
	   std::vector<std::vector<std::pair<float,float> > > AllParams,
	   std::vector<std::string> ParamNames, int lastnumrun,
	   std::string filename);

// this is for running the step2 process on a completed step1 run
// for the parallel
/*
struct Param{

  float *real;
  float *imag;
  int numparam;
};
*/

int main(int argc, char* argv[]){


  int myid;
  int numprocs;
  int namelen;
  char   processor_name[MPI_MAX_PROCESSOR_NAME];
  int headnode=0;
  int lastnumrun;

  std::ifstream fin;
  std::string proc_name_str;
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD,&numprocs);
  MPI_Comm_rank(MPI_COMM_WORLD,&myid);
  MPI_Get_processor_name(processor_name,&namelen);
  proc_name_str = processor_name;
  //  MPI_Datatype strtype;
  
  
  bool firstrun = true;
  ToSave *TheFiles;
  std::string filename;
  int numsubfolders;
  int numfiles;
  int numparam;
  //ToSave *TheFiles;
  //Params *AllParams;

  std::vector<std::vector<std::pair<float,float> > > AllParams;
  std::vector<std::string> ParamNames;
  std::stringstream commandss;
  //bool firstrun;
  // std::ifstream fin; 
  
  //if (myid == 0){
  for (int i = 0; i < argc; ++i){
    commandss << argv[i] << " ";
  }
  
  if (argc!=1){
    std::string blank;
    commandss >> blank;
    commandss >> filename;
    commandss >> numfiles;
    
    std::string fnamelastrun = "bfiles_";
    fnamelastrun.append(filename);
    fnamelastrun.append("/step2/tmp/lastrun");
    fin.open(fnamelastrun.c_str());
    if (fin.is_open()){
      fin >> lastnumrun;
      std::cout << "Reading in lastnumrun and setting to " << lastnumrun
		<< "\n";
    }
    else{
      lastnumrun=0;
      std::cout << "Did not read in lastnumrun and setting to " 
		<< lastnumrun << "\n";
    }
    //    std::cout << "lastnumrun = " << lastnumrun << "\n";
    fin.close();
    TheFiles = new ToSave[numfiles];
    for (int i = 0; i < numfiles;++i){
      commandss >> TheFiles[i].filename;
      TheFiles[i].saved = true;
      commandss >> TheFiles[i].filecount;
    }  
    commandss >> firstrun;
    commandss >> numsubfolders;
    commandss >> numparam;
    // AllParams = new Params[numsubfolders];
    
    for (int i = 0; i < numsubfolders;++i){
      // AllParams[i].real = new float[numparam];
      // AllParams[i].imag = new float[numparam];
      std::vector<std::pair<float,float> > CValuesVect;
      for (int j = 0; j < numparam;++j){
	float real;
	float imag;
	commandss >> real
		  >> imag;
	CValuesVect.push_back(std::pair<float,float>(real,imag));
	//commandss >> AllParams[i].real[j]
	//	  >> AllParams[i].imag[j];
      }
      AllParams.push_back(CValuesVect);
    }
    for (int i = 0; i < numparam;++i){
      std::string param;
      commandss >> param;
      ParamNames.push_back(param);
    }
  }
  else{
    // didn't provide filename or any arguments ...
    std::cerr << "Nothing passed as an argument ... this"
	      << " should never pop up as this program is only "
	      << "ever called from polysaurus...\n";
    return 1;
  }
  
  std::string basedir="bfiles_";
  basedir.append(filename);
  basedir.append("/");
  std::string DataCollectedBaseDir = basedir;
  DataCollectedBaseDir.append("step2/DataCollected/");



  std::vector<std::string> tmpfolderlocs;
  int foldersdone=0;
  for (int i = 0; i < numsubfolders;++i){
    std::stringstream tmpfolder;
    tmpfolder << "bfiles_" << filename << "/step2/"
	      << "tmp/"
	      << i
	      << "/";
    tmpfolderlocs.push_back(tmpfolder.str());
  }
  
  if(myid==headnode){ // head node stuff
    std::cout << "I'm the head node,  " << myid << " of "
	      << numprocs << " on "
	      << processor_name << "\n";
    
    std::string mydirfname = basedir;
    mydirfname.append("folders");
    std::ofstream fout(mydirfname.c_str());
   
    for (int i = 1; i < numprocs;++i){
      std::stringstream tmpfolder;
      tmpfolder << DataCollectedBaseDir;
      tmpfolder << "c";
      tmpfolder << i;
      fout << tmpfolder.str() << (i!=numprocs-1 ? "\n" :  "");      
    }
    fout.close();
  }
  else{ // worker node stuff 
    // sleep(1);
    //  std::cout << "Worker node, " << myid << " of "
    //  	      << numprocs << " on "
    //	      << processor_name << "\n";
    // create the correct folder datacollection names for each node
    //DataCollectedBaseDir.append(proc_name_str);
    DataCollectedBaseDir.append("c");
    std::stringstream ss;
    ss << myid;
    DataCollectedBaseDir.append(ss.str());
    DataCollectedBaseDir.append("/");
    mkdirunix(DataCollectedBaseDir.c_str());
    //   std::cout << "Created : " << DataCollectedBaseDir 
    //	      << " for Data Collection of step2 files\n";
    // touch the files that are to be saved ...
    //  if (firstrun){
    //   std::cout << "Inside mystep2\n";
    //   TouchFilesToSave(TheFiles,numfiles,DataCollectedBaseDir);
    // }
  }
  
  // test if numsubfolders < num_processes 

  if (myid==headnode){
    master(tmpfolderlocs);
  }
  else{
    slave(tmpfolderlocs, TheFiles, numfiles, 
	  AllParams,ParamNames,lastnumrun,filename);
  }
  if (myid==headnode){

    // update lastnumrun
    std::ofstream flastnumrun;
    std::string lastnumrunstr="bfiles_";
    lastnumrunstr.append(filename);
    lastnumrunstr.append("/step2/tmp/lastrun");
    flastnumrun.open(lastnumrunstr.c_str());
    flastnumrun << lastnumrun+numsubfolders;
    flastnumrun.close();


  }
  // delete[] AllParams;
  delete[] TheFiles;
  MPI_Finalize();
}


void master(std::vector<std::string> dir){
  int numsubfolders = dir.size();
  int ntasks, rank;
  int maxfolderdone = 0;
  int currentfolderdone = 0;
  //  unit_of_work_t work;
  // unit_result_t result;
  MPI_Status status;

  /* Find out how many processes there are in the default
     communicator */

  MPI_Comm_size(MPI_COMM_WORLD, &ntasks);


  /* Seed the slaves; send one unit of work to each slave. */

  for (rank = 1; rank < ntasks; ++rank) {
    
    /* Find the next item of work to do */
    

    /* Send it to each rank */
    maxfolderdone = currentfolderdone;
    std::cout << "sending maxfolder : " << maxfolderdone << " to process : " << rank
	      << "\n";
    int numtodo = ((numsubfolders - maxfolderdone)-1)/(ntasks-1) + 1;

    MPI_Send(&maxfolderdone,      /* message buffer */
             1,                 /* one data item */
             MPI_INT,           /* data item is an integer */
             rank,              /* destination process rank */
             numtodo,           /* user chosen message tag */
             MPI_COMM_WORLD);   /* default communicator */
    currentfolderdone+=numtodo;
    
    
    //   std::cout << "Incremented foldersdone in " << 0 << ".\n";
  }

  /* Loop over getting new work requests until there is no more work
     to be done */
  
  //  work = get_next_work_item();

  while (maxfolderdone < numsubfolders) {
    
    /* Receive results from a slave */

    MPI_Recv(&currentfolderdone,       /* message buffer */
             1,                 /* one data item */
             MPI_INT,           /* of type int */
             MPI_ANY_SOURCE,    /* receive from any sender */
             MPI_ANY_TAG,       /* any type of message */
             MPI_COMM_WORLD,    /* default communicator */
             &status);          /* info about the received message */

    std::cout << "received currentfolderdone : " << currentfolderdone << " from " 
	      << status.MPI_SOURCE
	      << "\n";


    /*  if (currentfolderdone == maxfolderdone){
      // do nothing
      ++maxfolderdone;

      }
    else{ // otherwise increment maxfoldersdone
      ++maxfolderdone;
    }
    */





    std::cout << "incrementing maxfolder to " << maxfolderdone+int(status.MPI_TAG) << "\n";
    maxfolderdone+=int(status.MPI_TAG);

    /*  std::cout << "received message back : folders done = " << currentfolderdone << "\n";
    std::cout << "max folder done = " << maxfolderdone << "\n";
    */


    /* Send the slave a new work unit */


    std::cout << "sending maxfolder : " << maxfolderdone << " to " << status.MPI_SOURCE << "\n";
    
    //  if (maxfolderdone < numsubfolders){


    int numtodo = ((numsubfolders - maxfolderdone)-1)/(ntasks-1) + 1;

    MPI_Send(&maxfolderdone,             /* message buffer */
	     1,                 /* one data item */
	     MPI_INT,           /* data item is an integer */
	     status.MPI_SOURCE, /* to who we just received from */
	     numtodo,           /* user chosen message tag */
	     MPI_COMM_WORLD);   /* default communicator */
    //    }
    //   else{
    // send kill message
    //     MPI_Send(&maxfolderdone,1,MPI_INT,status.MPI_SOURCE,1,MPI_COMM_WORLD);
    //   }
    //   else{
    // do nothing
    //    }
    /* Get the next unit of work to be done */
    
    /*
    if (currentfoldersdone == maxfoldersdone){
      // do nothing

    }
    else{ // otherwise increment maxfoldersdone
    ++maxfolderdone;
    }
    */
    //   ++maxfolderdone;

  }
  
  /* There's no more work to be done, so receive all the outstanding
     results from the slaves. */
  
  for (rank = 1; rank < ntasks; ++rank) {
    MPI_Recv(&currentfolderdone, 1, MPI_INT, MPI_ANY_SOURCE,
             MPI_ANY_TAG, MPI_COMM_WORLD, &status);

    std::cout << "received currentfolderdone : " << currentfolderdone << "from " << status.MPI_SOURCE
	      << "\n";

  }

  /* Tell all the slaves to exit by sending an empty message with the
     DIETAG. */
  
  for (rank = 1; rank < ntasks; ++rank) {

    std::cout << "Sending kill tag to rank " << rank << "\n";

    MPI_Send(0, 0, MPI_INT, rank, 0, MPI_COMM_WORLD);
  }  
}



void slave(std::vector<std::string> dir, ToSave *TheFiles, int numfiles,
	   std::vector<std::vector<std::pair<float,float> > > AllParams,
	   std::vector<std::string> ParamNames, int lastnumrun,
	   std::string filename){
  int myid;
  MPI_Comm_rank(MPI_COMM_WORLD,&myid);
  MPI_Status status;
  int currentfolderdone;
  std::stringstream myss;
  myss << "bfiles_" << filename << "/step2/DataCollected/c"
       << myid << "/";
  std::string DataCollectedBaseDir = myss.str();
  
  while (1) {

    /* Receive a message from the master */

    MPI_Recv(&currentfolderdone, 1, MPI_INT, 0, MPI_ANY_TAG,
             MPI_COMM_WORLD, &status);

    /* Check the tag of the received message. */

    if (status.MPI_TAG == 0) {
      std::cout << "received kill tag to rank " << myid << "\nkilling now\n";
      return;
    }

    std::cout << "Received work to do on folder : " << currentfolderdone
	      << " in rank " << myid << "\n";



    int increasecount = 0;
    for (int k = 0; k < int(status.MPI_TAG);++k){

      if (currentfolderdone != dir.size()){

	/* Do the work */
      
	//    std::cout << "The directory to run bertini is " << dir[foldersdone]
	//	      << "\n";
	
	// Call Bertini
      
	CallBertiniStep2(dir[currentfolderdone]);
	
	
	// Collect the Data
	std::string base_dir = "bfiles_";
	base_dir.append(filename);
	base_dir.append("/");
	bool append;
	for (int j = 0; j < numfiles;++j){
	  
	  std::string target_file =
	    MakeTargetFilename(DataCollectedBaseDir,
			       TheFiles,
			       j);
	  std::cout << "target_file = " << target_file << "\n";
	  std::string orig_file = dir[currentfolderdone];
	  //     orig_file.append(dir[foldersdone]);
	  orig_file.append(TheFiles[j].filename);
	  std::cout << "original file = " << orig_file << ", target file = " 
		    << target_file << "\n";
	  WriteData(lastnumrun+currentfolderdone, 
		    orig_file, 
		    target_file,
		    //		append,
		    ParamNames,
		    AllParams[currentfolderdone]);	    		
	  
	}
	
	
	std::cout << "Finished doing work on folder : " << currentfolderdone << " on rank " << myid 
		  << "\n";
	++currentfolderdone;
	++increasecount;
      }
    }
    currentfolderdone-=increasecount;
    MPI_Send(&currentfolderdone, 1, MPI_INT, 0, int(status.MPI_TAG), MPI_COMM_WORLD);
  }
  
}






